Since the only valid signature of a command we know is echo cool, to get passed the validation we need to keep the command and its signature in the json or else we wont get passed validation. Once we establish that those need to be there, we need some how to insert our command; though it's a dictionary, we cant simply add another instance, i.e a duplicate - it will over ride each other and only one of them will remain - which is not good, either "hacked" wont get printed or we wont get passed validation.
So looking at how bob implemented the execution, it reads the json as a string, not as json.load which returns a dict. So he searches with re module the first occurrence of "command": "somecmd", but, it needs not to be catched by alice in her implementation (i.e the key name should not be command) or else, again, we wont get passed validation.
So finally, we get to the conclusion that we need to get our malicous "command": "echo hacked" inside some structure, while its key name isn't command. So we add a key, in my case bla, his value is a python list [], in it needs to be our "command": "echo hacked". Since a list can't have dict like items, in the list there will be a dict with "command": "echo hacked" and since bob just searches for that occurence as a string, it will catch that and execute echo hacked as wanted.