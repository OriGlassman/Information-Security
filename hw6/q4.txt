I pad 66 nops and then comes the code - as the instructions mentioned, I loaded the address of puts into ebp (basically what happens when puts is called, the esp is just above the address of puts in the stack, so the first push  ebp into the stack in the function will override the address of puts. The fix to it is to put the address in ebp, then basically push ebp and pop ebp doesn't ruin the address of puts for future calls, push and pop ebp happens in the prolog and epilog of the function).
After the addresses that point to load the address of puts into ebp, comes the address of ebp and then comes an adress that skips 4 bytes (aka increases stack by 4). The reason of doing so is we needed to put the address to the string in the place of the first argument of puts, so if after returning back from puts we wouldn't skip 4 bytes, we would jump to the address of the string and try to execute it, which of course will lead to seg violation, so we skip 4 bytes to not try to execute the string. At this time let me note that inside puts, it may modify the stack at lower addresses but it wont effect the loop since once the instructions below were executed once, they dont need to happen again (ebp wont change etc) and that is why the loop works !.
I've put the string highest on the stack, so that it wont get overrided, and could calculate statically the offset it will be in the stack. 